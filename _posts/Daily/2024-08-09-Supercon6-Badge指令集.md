---
title: 2022-Supercon6-Badge Instruction Set
key: Supercon6-Badge指令集
tags: ["Daily"]
aside:
  toc: true
---

## 2022-Supercon6-Badge 指令集 <!--more-->

# 前言
此指令集仅适用于 2022-Supercon6-Badge，其他设备请参考相应文档。

**版权由原作者享有，本文档仅用于学习和交流。**

源文档[2.Instruction_Set_v4.pdf](https://github.com/Hack-a-Day/2022-Supercon6-Badge-Tools/blob/main/manuals/2.Instruction_Set_v4.pdf)

## 指令集全31条

![Image](/assets/images/Daily/屏幕截图%202024-08-09%20211156.png)

### ADD RX,RY

- **语法**: `ADD RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) + (RY)`
- **描述**: 将寄存器 `RY` 的内容加到寄存器 `RX` 中，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **C**: 如果发生溢出（即 `(RX) + (RY) > 15`），设置 `C` 标志，否则重置 `C` 标志。
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
  - **V**: 如果发生带符号的二进制补码溢出，设置 `V` 标志，否则重置 `V` 标志。
- **编码**: `0001 XXXX YYYY`
  - `0001` 表示 `ADD RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `ADD R2,R0`

### ADC RX,RY

- **语法**: `ADC RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) + (RY) + Carry`
- **描述**: 将寄存器 `RY` 和进位标志的内容加到寄存器 `RX` 中，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **C**: 如果发生借位（即 `(RY) < (RX)`），重置 `C` 标志，否则设置 `C` 标志。
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
  - **V**: 如果发生带符号的二进制补码溢出，设置 `V` 标志，否则重置 `V` 标志。
- **编码**: `0010 XXXX YYYY`
  - `0010` 表示 `ADC RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `ADC R1,R7`

### SUB RX,RY

- **语法**: `SUB RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) - (RY)`
- **描述**: 将寄存器 `RY` 的内容从寄存器 `RX` 中减去，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **C**: 如果发生借位（即 `(RY) < (RX)`），重置 `C` 标志，否则设置 `C` 标志。
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
  - **V**: 如果发生带符号的二进制补码溢出，设置 `V` 标志，否则重置 `V` 标志。
- **编码**: `0011 XXXX YYYY`
  - `0011` 表示 `SUB RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `SUB R6,R2`

### SBB RX,RY

- **语法**: `SBB RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) - (RY) - Carry`
- **描述**: 将寄存器 `RY` 和借位标志的内容从寄存器 `RX` 中减去，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **C**: 如果发生借位（即 `(RY) < (RX)`），重置 `C` 标志，否则设置 `C` 标志。
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
  - **V**: 如果发生带符号的二进制补码溢出，设置 `V` 标志，否则重置 `V` 标志。
- **编码**: `0100 XXXX YYYY`
  - `0100` 表示 `SBB RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `SBB R5,R3`

### OR RX,RY

- **语法**: `OR RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) .OR. (RY)`
- **描述**: 对寄存器 `RX` 和 `RY` 执行逻辑“或”操作，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0101 XXXX YYYY`
  - `0101` 表示 `OR RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `OR R0,R7`

### AND RX,RY

- **语法**: `AND RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) .AND. (RY)`
- **描述**: 对寄存器 `RX` 和 `RY` 执行逻辑“与”操作，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0110 XXXX YYYY`
  - `0110` 表示 `AND RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `AND R10,R11`

### XOR RX,RY

- **语法**: `XOR RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RX) .XOR. (RY)`
- **描述**: 对寄存器 `RX` 和 `RY` 执行逻辑“异或”操作，并将结果存储在 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**:
  - **Z**: 如果结果为 `0000`，设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0111 XXXX YYYY`
  - `0111` 表示 `XOR RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `XOR R8,R3`

### MOV RX,RY

- **语法**: `MOV RX,RY`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `RY`: 源寄存器 [R0...R15]
- **操作**: `(RX) ← (RY)`
- **描述**: 将寄存器 `RY` 的内容移动到寄存器 `RX` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**: 无
- **编码**: `1000 XXXX YYYY`
  - `1000` 表示 `MOV RX,RY` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `MOV R6,R5`

### MOV RX,N

- **语法**: `MOV RX,N`
- **操作数**:
  - `RX`: 目标寄存器 [R0...R15]
  - `N`: 4 位字面值 [0...15]
- **操作**: `(RX) ← N`
- **描述**: 将 4 位字面值 `N` 移动到寄存器 `RX` 中。寄存器直接寻址模式用于 `RX`。
- **影响的标志位**: 无
- **编码**: `1001 XXXX NNNN`
  - `1001` 表示 `MOV RX,N` 操作码
  - `XXXX` 选择操作数 `RX`
  - `NNNN` 表示字面值 `N`
- **示例**: `MOV R9,7`

### MOV [XY],R0

- **语法**: `MOV [XY],R0`
- **操作数**:
  - `RX`: 高半字节寄存器 [R0...R15]
  - `RY`: 低半字节寄存器 [R0...R15]
  - `R0`: 源寄存器
- **操作**: `((RX):(RY)) ← (R0)`
- **描述**: 将寄存器 `R0` 的 4 位内容移动到由寄存器 `RX`（高半字节）和 `RY`（低半字节）间接寻址的数据存储器中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**: 无
- **编码**: `1010 XXXX YYYY`
  - `1010` 表示 `MOV [XY],R0` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `MOV [R6:R4],R0`

### MOV R0,[XY]

- **语法**: `MOV R0,[XY]`
- **操作数**:
  - `RX`: 高半字节寄存器 [R0...R15]
  - `RY`: 低半字节寄存器 [R0...R15]
- **操作**: `(R0) ← ((RX):(RY))`
- **描述**: 将由寄存器 `RX`（高半字节）和 `RY`（低半字节）间接寻址的数据存储器的 4 位内容移动到寄存器 `R0` 中。寄存器直接寻址模式用于 `RX` 和 `RY`。
- **影响的标志位**: 无
- **编码**: `1011 XXXX YYYY`
  - `1011` 表示 `MOV R0,[XY]` 操作码
  - `XXXX` 选择操作数 `RX`
  - `YYYY` 选择操作数 `RY`
- **示例**: `MOV R0,[R4:R7]`

### MOV [NN],R0

- **语法**: `MOV [NN],R0`
- **操作数**:
  - `NN`: 8 位字面值 [0...255]
  - `R0`: 源寄存器
- **操作**: `(NN) ← (R0)`
- **描述**: 将寄存器 `R0` 的 4 位内容移动到由无符号字面值 `NN` 寻址的数据存储器中。
- **影响的标志位**: 无
- **编码**: `1100 NNNN NNNN`
  - `1100` 表示 `MOV [NN],R0` 操作码
  - `NNNNNNNN` 表示字面值 `NN`
- **示例**: `MOV [0x19], R0`

### MOV R0,[NN]

- **语法**: `MOV R0,[NN]`
- **操作数**:
  - `NN`: 8 位字面值 [0...255]
- **操作**: `(R0) ← (NN)`
- **描述**: 将由无符号字面值 `NN` 寻址的数据存储器的 4 位内容移动到寄存器 `R0` 中。寄存器直接寻址模式用于 `R0`。
- **影响的标志位**: 无
- **编码**: `1101 NNNN NNNN`
  - `1101` 表示 `MOV R0,[NN]` 操作码
  - `NNNNNNNN` 表示字面值 `NN`
- **示例**: `MOV R0,[0xE2]`

### MOV PC,NN

- **语法**: `MOV PC,NN`
- **操作数**:
  - `NN`: 8 位字面值 [0...255]
- **操作**: `(R14) ← NN bit3...bit0, (R15) ← NN bit7...bit4`
- **描述**: 将 8 位字面值 `NN` 的低 4 位移动到寄存器 `R14`，高 4 位移动到寄存器 `R15`。
- **影响的标志位**: 无
- **编码**: `1110 NNNN NNNN`
  - `1110` 表示 `MOV PC,NN` 操作码
  - `NNNNNNNN` 表示字面值 `NN`
- **示例**: `MOV PC,0x31`

### JR NN

- **语法**: `JR NN`
- **操作数**:
  - `NN`: 有符号 8 位字面值 [-128...+127]
- **操作**: `PC ← PC + NN`
- **描述**: 将签名整数值 `NN` 加到程序计数器 `PC` 中，实现相对跳转。
- **影响的标志位**: 无
- **编码**: `1111 NNNN NNNN`
  - `1111` 表示 `JR NN` 操作码
  - `NNNNNNNN` 表示有符号字面值 `NN`
- **示例**: `JR -3`

### CP R0,N

- **语法**: `CP R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `(R0) - N`
- **描述**: 计算无符号 `R0 - N` 并更新 `C` 和 `Z` 标志。减法结果不会存储，仅影响标志位。
- **影响的标志位**:
  - **C**: 如果 `(R0) > N` 或 `(R0) = N`，则设置 `C` 标志，否则重置 `C` 标志。
  - **Z**: 如果 `(R0) = N`，则设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 0000 NNNN`
  - `0000 0000` 表示 `CP R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `CP R0,5`

### ADD R0,N

- **语法**: `ADD R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `(R0) ← (R0) + N`
- **描述**: 将字面值 `N` 加到寄存器 `R0` 中，并将结果存储在 `R0` 中。
- **影响的标志位**:
  - **C**: 如果发生溢出（即 `(R0) + N > 15`），则设置 `C` 标志，否则重置 `C` 标志。
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 0001 NNNN`
  - `0000 0001` 表示 `ADD R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `ADD R0,14`

### INC RY

- **语法**: `INC RY`
- **操作数**:
  - `RY`: 寄存器 [R0...R15]
- **操作**: `(RY) ← (RY) + 1`
- **描述**: 将寄存器 `RY` 的内容加 1，并将结果存储在 `RY` 中。
- **影响的标志位**:
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
  - **C**: 如果结果为 `0000`，则设置 `C` 标志，否则重置 `C` 标志。
- **编码**: `0000 0010 YYYY`
  - `0000 0010` 表示 `INC RY` 操作码
  - `YYYY` 选择操作数 `RY`
- **示例**: `INC R3`

### DEC RY

- **语法**: `DEC RY`
- **操作数**:
  - `RY`: 寄存器 [R0...R15]
- **操作**: `(RY) ← (RY) - 1`
- **描述**: 将寄存器 `RY` 的内容减 1，并将结果存储在 `RY` 中。
- **影响的标志位**:
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
  - **C**: 如果结果为 `1111`，则重置 `C` 标志，否则设置 `C` 标志。
- **编码**: `0000 0011 YYYY`
  - `0000 0011` 表示 `DEC RY` 操作码
  - `YYYY` 选择操作数 `RY`
- **示例**: `DEC R8`

### DSZ RY

- **语法**: `DSZ RY`
- **操作数**:
  - `RY`: 寄存器 [R0...R15]
- **操作**: `(RY) ← (RY) - 1, if result is =0, then PC ← PC + 1`
- **描述**: 将寄存器 `RY` 的内容减 1，如果结果为 0，则程序计数器 `PC` 增加 1。
- **影响的标志位**: 无
- **编码**: `0000 0100 YYYY`
  - `0000 0100` 表示 `DSZ RY` 操作码
  - `YYYY` 选择操作数 `RY`
- **示例**: `DSZ R3`

### OR R0,N

- **语法**: `OR R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `(R0) ← (R0) .OR. N`
- **描述**: 计算寄存器 `R0` 与字面值 `N` 的逻辑“或”操作，并将结果存储在 `R0` 中。
- **影响的标志位**:
  - **C**: 无条件设置 `C` 标志。
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 0101 NNNN`
  - `0000 0101` 表示 `OR R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `OR R0,6`

### AND R0,N

- **语法**: `AND R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `(R0) ← (R0) .AND. N`
- **描述**: 计算寄存器 `R0` 与字面值 `N` 的逻辑“与”操作，并将结果存储在 `R0` 中。
- **影响的标志位**:
  - **C**: 无条件重置 `C` 标志。
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 0110 NNNN`
  - `0000 0110` 表示 `AND R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `AND R0,10`

### XOR R0,N

- **语法**: `XOR R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `(R0) ← (R0) .XOR. N`
- **描述**: 计算寄存器 `R0` 与字面值 `N` 的逻辑“异或”操作，并将结果存储在 `R0` 中。
- **影响的标志位**:
  - **C**: 无条件翻转 `C` 标志。
  - **Z**: 如果结果为 `0000`，则设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 0111 NNNN`
  - `0000 0111` 表示 `XOR R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `XOR R0,3`

### EXR N

- **语法**: `EXR N`
- **操作数**:
  - `N`: 4 位字面值 [0...15]（特殊情况：`N=0` 表示交换 16 个寄存器）
- **操作**: `(R0)...(RN) ↔ (0xE0)...(0xEN)`
- **描述**: 将页面 0 中的 `N` 个寄存器与页面 14（页面 0x0E）中的相应寄存器进行交换。如果 `N=0`，则交换 16 个寄存器。
- **影响的标志位**: 无
- **编码**: `0000 1000 NNNN`
  - `0000 1000` 表示 `EXR N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `EXR 10`

### BIT RG,M

- **语法**: `BIT RG,M`
- **操作数**:
  - `RG`: 寄存器 [R0...R15]
  - `M`: 位位置 [0...3]
- **操作**: `Z ← (RG) .BIT. M`
- **描述**: 测试寄存器 `RG` 中第 `M` 位，并根据测试结果设置 `Z` 标志。如果该位为 0，`Z` 标志置位；否则，`Z` 标志重置。
- **影响的标志位**:
  - **Z**: 如果结果为 `0`，设置 `Z` 标志，否则重置 `Z` 标志。
- **编码**: `0000 1001 GGGG MMMM`
  - `0000 1001` 表示 `BIT RG,M` 操作码
  - `GGGG` 选择寄存器 `RG`
  - `MMMM` 表示位位置 `M`
- **示例**: `BIT R5,2`

### BSET RG,M

- **语法**: `BSET RG,M`
- **操作数**:
  - `RG`: 寄存器 [R0...R15]
  - `M`: 位位置 [0...3]
- **操作**: `(RG) ← (RG) .BSET. M`
- **描述**: 设置寄存器 `RG` 中第 `M` 位。
- **影响的标志位**: 无
- **编码**: `0000 1010 GGGG MMMM`
  - `0000 1010` 表示 `BSET RG,M` 操作码
  - `GGGG` 选择寄存器 `RG`
  - `MMMM` 表示位位置 `M`
- **示例**: `BSET R7,1`

### BCLR RG,M

- **语法**: `BCLR RG,M`
- **操作数**:
  - `RG`: 寄存器 [R0...R15]
  - `M`: 位位置 [0...3]
- **操作**: `(RG) ← (RG) .BCLR. M`
- **描述**: 清除寄存器 `RG` 中第 `M` 位。
- **影响的标志位**: 无
- **编码**: `0000 1011 GGGG MMMM`
  - `0000 1011` 表示 `BCLR RG,M` 操作码
  - `GGGG` 选择寄存器 `RG`
  - `MMMM` 表示位位置 `M`
- **示例**: `BCLR R3,0`

### BTG RG,M

- **语法**: `BTG RG,M`
- **操作数**:
  - `RG`: 寄存器 [R0...R15]
  - `M`: 位位置 [0...3]
- **操作**: `(RG) ← (RG) .BTG. M`
- **描述**: 切换寄存器 `RG` 中第 `M` 位的状态。
- **影响的标志位**: 无
- **编码**: `0000 1100 GGGG MMMM`
  - `0000 1100` 表示 `BTG RG,M` 操作码
  - `GGGG` 选择寄存器 `RG`
  - `MMMM` 表示位位置 `M`
- **示例**: `BTG R4,3`

### RRC RY

- **语法**: `RRC RY`
- **操作数**:
  - `RY`: 寄存器 [R0...R15]
- **操作**: `(RY) ← (RY) .RRC`
- **描述**: 将寄存器 `RY` 的内容通过进位标志右移一位。
- **影响的标志位**:
  - **C**: 将 `RY` 的最低位传送到进位标志 `C`。
- **编码**: `0000 1101 YYYY`
  - `0000 1101` 表示 `RRC RY` 操作码
  - `YYYY` 选择操作数 `RY`
- **示例**: `RRC R2`

### RET R0,N

- **语法**: `RET R0,N`
- **操作数**:
  - `R0`: 寄存器
  - `N`: 4 位字面值 [0...15]
- **操作**: `PC ← ((R0) + N)`
- **描述**: 从子程序返回，并可选择性地将字面值 `N` 加到程序计数器 `PC` 中。
- **影响的标志位**: 无
- **编码**: `0000 1110 NNNN`
  - `0000 1110` 表示 `RET R0,N` 操作码
  - `NNNN` 表示字面值 `N`
- **示例**: `RET R0,5`

### SKIP F,M

- **语法**: `SKIP F,M`
- **操作数**:
  - `F`: 标志位 [C, Z, V]
  - `M`: 4 位字面值 [0...15]
- **操作**: `if (F set) then PC ← PC + M`
- **描述**: 根据标志 `F` 的状态，条件性地跳过 `M` 条指令。
- **影响的标志位**: 无
- **编码**: `0000 1111 FFFM`
  - `0000 1111` 表示 `SKIP F,M` 操作码
  - `FFF` 表示选择的标志位 `F`
  - `M` 表示字面值 `M`
- **示例**: `SKIP Z,2`
